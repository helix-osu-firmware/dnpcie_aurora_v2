------------------------------------------------------------------------------
-- Project:  Aurora 8B/10B
-- Version:  version 11.0
-- Company:  Xilinx 
--
--
-- (c) Copyright 2012 - 2013 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.

--
--------------------------------------------------------------------------------
--
-- Module aurora_8b10b_TX_CRC
-- Generated by Xilinx Aurora 8B10B
---------------------------------------------------------------------
-- Library Declarations
---------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
use ieee.numeric_std.all;

ENTITY aurora_aux_TX_CRC IS
PORT
  (
DATA_DS                        : OUT std_logic_vector(15 downto 0) := (others => '0');
REM_DS                         : OUT std_logic := '0'; 
    SOF_N_DS                       : OUT std_logic := '0';
    EOF_N_DS                       : OUT std_logic := '0';
    SRC_RDY_N_DS                   : OUT std_logic := '0';
    DST_RDY_N_US                   : OUT std_logic;
DATA_US                        : IN  std_logic_vector(15 downto 0);
REM_US                         : IN  std_logic; 
    SOF_N_US                       : IN  std_logic;
    EOF_N_US                       : IN  std_logic;
    SRC_RDY_N_US                   : IN  std_logic;
    DST_RDY_N_DS                   : IN  std_logic;
    RESET                          : IN  std_logic;
    CLK                            : IN  std_logic
  );
END aurora_aux_TX_CRC;

ARCHITECTURE TX_CRC_ARCH of aurora_aux_TX_CRC is

    constant DLY : time := 1 ns;
        

--__Signal declaration for one-hot encoded FSM__
  signal  idle_r    : std_logic := '1';    --Idle or power on state
  signal  sc_frame_r: std_logic := '0';    --single cycle frame state
  signal  sof_sc_r  : std_logic := '0';    --sof state for single cycle frame when rem > 3
  signal  eof_sc_r  : std_logic := '0';    --eof state for single cycle frame when rem > 3
  signal  wait_r    : std_logic := '0';    --wait state
  signal  sof_ds_r  : std_logic := '0';    --build sof state for non-single cycle frames
  signal  src_not_rdy_r: std_logic := '0';   --state for input src not rdy
  signal  data_r    : std_logic := '0';    --data state
  signal  eof_ds_r  : std_logic := '0';    --build eof state
  signal  crc_r     : std_logic := '0';    --append crc state for rem>3
 
  signal  idle_c    : std_logic;
  signal  sc_frame_c: std_logic;
  signal  sof_sc_c  : std_logic;
  signal  eof_sc_c  : std_logic;
  signal  wait_c    : std_logic;
  signal  sof_ds_c  : std_logic;
  signal  src_not_rdy_c : std_logic;
  signal  data_c    : std_logic;
  signal  eof_ds_c  : std_logic;
  signal  crc_c     : std_logic;
 
signal  rem_in    : std_logic := '0';  --store input REM
  signal  EOF_N_US_r: std_logic := '0';                    --EOF delayed by one cycle
  signal  count     : std_logic_vector (1 downto 0) := (others=>'0');    --count to deassert dst-rdy-us after receiving EOF
signal  DATA_US_r : std_logic_vector(15 downto 0) := (others=>'0'); --data input pipeline-I
signal  DATA_US_2r: std_logic_vector(15 downto 0) := (others=>'0'); --data input pipeine-II
signal  CRC_reg     : std_logic_vector(15 downto 0) := (others=>'0');   --CRC output registered from CRC block
 
  signal  DST_RDY_N_US_i  : std_logic;
  signal  ll_valid        : std_logic;    --__LocalLink valid
  signal  CRC1             : std_logic_vector(15 downto 0);   --__CRC calculated for lane1
  signal  CRC_DATAVALID1             : std_logic;   --__CRC datavalid for lane1
  signal  CRC_RESET       : std_logic;    --__reset to CRC block
  signal  CRC_DATAWIDTH1   : std_logic;  --__CRC datawidth for lane1
signal  CRC_DATA1        : std_logic_vector(15 downto 0); --__data input to CRC block for lane1
signal  final_CRC       : std_logic_vector(15 downto 0); 
  signal  crc_datawidth1_temp   : std_logic;  --__CRC datawidth temp signal for lane1
  signal  crc_datavalid1_temp   : std_logic;  --__CRC datavalid temp signal for lane1
signal  tied_to_ground        :   std_logic_vector(15 downto 0);
signal  data_us_temp1         : std_logic_vector(15 downto 0);
signal  data_us_temp2         : std_logic_vector(15 downto 0);


  component aurora_aux_CRC_TOP
  generic (
    CRC_INIT   : bit_vector := X"FFFF"
     );   
  port (
    CRCOUT            : out std_logic_vector(15 downto 0);
 
    CRCCLK            : in  std_ulogic;
    CRCDATAVALID      : in  std_ulogic;
    CRCDATAWIDTH      : in  std_logic;
    CRCIN             : in  std_logic_vector(15 downto 0);
    CRCRESET          : in  std_ulogic
  );
  end component; 


begin     

      --____________Main code begins here________________--
    tied_to_ground <= (others => '0');	
      --__Initialization & state assignment for FSM__--
     
      process (CLK)
      begin
        if (CLK'event and CLK = '1') then
          if (RESET = '1') then
            idle_r        <=  '1' after DLY;
            sc_frame_r    <=  '0' after DLY;
            sof_sc_r      <=  '0' after DLY;
            eof_sc_r      <=  '0' after DLY;
            wait_r        <=  '0' after DLY;
            src_not_rdy_r <=  '0' after DLY;
            sof_ds_r      <=  '0' after DLY;
            data_r        <=  '0' after DLY;
            eof_ds_r      <=  '0' after DLY;
            crc_r         <=  '0' after DLY;
          elsif (DST_RDY_N_DS = '0') then
            idle_r        <=  idle_c after DLY;
            sc_frame_r    <=  sc_frame_c after DLY;
            sof_sc_r      <=  sof_sc_c after DLY;
            eof_sc_r      <=  eof_sc_c after DLY;
            wait_r        <=  wait_c after DLY;
            src_not_rdy_r <=  src_not_rdy_c after DLY;
            sof_ds_r      <=  sof_ds_c after DLY;
            data_r        <=  data_c after DLY;
            eof_ds_r      <=  eof_ds_c after DLY;
            crc_r         <=  crc_c after DLY;
         end if;
        end if;
    end process;

  --__Combinatorial logic for FSM__--
  idle_c  <= ((idle_r or eof_ds_r or eof_sc_r) and
							(SOF_N_US or (not ll_valid)));
           
  sc_frame_c  <= (idle_r or eof_ds_r or eof_sc_r) and (not SOF_N_US) and (not EOF_N_US) and ll_valid;
 
  sof_sc_c  <= sc_frame_r;
 
  eof_sc_c    <= sof_sc_r;
 
  wait_c  <= ((idle_r or eof_ds_r or eof_sc_r) and (not SOF_N_US) and EOF_N_US and ll_valid) or
             (wait_r and SRC_RDY_N_US);
 
  sof_ds_c  <= (wait_r and not SRC_RDY_N_US);
 
  src_not_rdy_c <= ((sof_ds_r or data_r) and SRC_RDY_N_US and EOF_N_US_r) or
                (src_not_rdy_r and SRC_RDY_N_US);
 
  data_c  <= (sof_ds_r and EOF_N_US_r) or
             (data_r and EOF_N_US_r and (not SRC_RDY_N_US)) or
             (src_not_rdy_r and (not SRC_RDY_N_US) and EOF_N_US_r);
 
  crc_c <= (sof_ds_r or data_r or (src_not_rdy_r and (not SRC_RDY_N_US))) and (not EOF_N_US_r);
 
  eof_ds_c  <= crc_r;       
    
  --__input signals registered__--
    process (CLK)
    begin
      if (CLK'event and CLK = '1') then
        if (ll_valid = '1') then
          EOF_N_US_r  <=  EOF_N_US after DLY;
          DATA_US_r <=  DATA_US after DLY; --data pipe-I
        end if;
      end if;
    end process;
 
   process (CLK)
    begin
      if (CLK'event and CLK = '1') then
        if (DST_RDY_N_DS='0') then
          DATA_US_2r <=  DATA_US_r after DLY; --data pipe-I
        end if;
      end if;
    end process;
  --__Store REM value and build output REM__
  process (CLK)
    begin
      if (CLK'event and CLK = '1') then
        if ((EOF_N_US = '0') and (ll_valid = '1')) then
          rem_in    <=  REM_US after DLY;            --input REM storage
        end if;
      end if;
  end process;

--deassert dst-rdy-us after EOF reception or when dst-rdy-ds is deasserted--
  DST_RDY_N_US    <=  DST_RDY_N_US_i;
  DST_RDY_N_US_i  <=  DST_RDY_N_DS  or count(0) or count(1) or RESET;
 
    --__deassert dst_rdy_n_us for 2 cycles after eof_n_us reception
      -- to take care of crc insertion in DS-data__
  process (CLK)
  begin
    if (CLK'event and CLK = '1') then
      if (RESET='1') then
        count   <=  "00" after DLY;
      elsif ((ll_valid='1') and (EOF_N_US='0')) then
        count   <=  "10" after DLY;
      elsif ((DST_RDY_N_DS='0') and (count /= "00")) then
        count   <=  '0' & count(1) after DLY;
      end if;
    end if;
  end process;
 
    --Localink valid indicator----
    ll_valid <= not (SRC_RDY_N_US or DST_RDY_N_US_i);

    --CRC reset assertion, this initializes the internal crc-reg with CRC_INIT value----
    CRC_RESET  <= (not SOF_N_US) and ll_valid;

    CRC_DATAWIDTH1      <= REM_US when (((not EOF_N_US) and ll_valid) = '1') else
                                   '1';
    CRC_DATAVALID1      <= ll_valid;
    CRC_DATA1           <= DATA_US(15 downto 0);

   --CRC Block instantiation for Lane1--
   tx_crc_gen1_i : aurora_aux_CRC_TOP
   generic map (
                           CRC_INIT                =>  x"FFFF"
               )
   port map    (
  
      CRCRESET          =>  CRC_RESET, 
      CRCCLK            =>  CLK,
      CRCDATAWIDTH      =>  CRC_DATAWIDTH1,
      CRCDATAVALID      =>  CRC_DATAVALID1,   
      --CRCIN             =>  CRC_DATA1,  
      CRCIN             =>  CRC_DATA1,  
      CRCOUT            =>  CRC1
   );
  
  
  final_CRC <= (
		CRC1 ); 
  

   --__Register CRC calculated__--
   process (CLK)
   begin
     if (CLK'event and CLK = '1') then
      CRC_reg <=  final_CRC after DLY;
     end if;
  end process;
 
  --__Build DS output controls__--
    process (CLK)
    begin
      if (CLK'event and CLK = '1') then
        if (RESET = '1') then
          SOF_N_DS      <=  '1' after DLY;
          EOF_N_DS      <=  '1' after DLY;
          SRC_RDY_N_DS  <=  '1' after DLY;
        elsif (DST_RDY_N_DS='0') then
          SOF_N_DS      <=  not (sof_ds_r or sof_sc_r) after DLY;
          EOF_N_DS      <=  not (eof_ds_r or eof_sc_r) after DLY;
          SRC_RDY_N_DS  <=  idle_r or src_not_rdy_r or wait_r or sc_frame_r after DLY;
        end if;
      end if;
    end process;

	process (CLK)
	begin
 	  if (CLK'event and CLK = '1') then
            if (RESET = '1') then
              REM_DS	<=	'1' after DLY;
            elsif (DST_RDY_N_DS='0') then
	      if ((eof_ds_r or eof_sc_r)='1') then
	        REM_DS	<=	rem_in after DLY;
	      else
                REM_DS	<=	'1' after DLY;
	      end if;
	    end if;
	  end if;
	end process;

    data_us_temp1    <=      
(DATA_US_2r(15 downto 8) & final_CRC(15 downto 8)) when (rem_in = '0')   else DATA_US_2r; 
    data_us_temp2    <=      
(CRC_reg(7 downto 0) & tied_to_ground(7 downto 0)) when (rem_in = '0')  else CRC_reg; 

    process (CLK)
      begin
        if(CLK'event and CLK = '1') then
          if(RESET = '1') then
            DATA_DS <=  (others => '0') after DLY;
          elsif (DST_RDY_N_DS='0') then
            if ((sof_sc_r or crc_r)='1') then
              DATA_DS <=  data_us_temp1 after DLY;
            elsif ((eof_sc_r or eof_ds_r)='1') then
              DATA_DS <=  data_us_temp2 after DLY; 
            else
              DATA_DS <=  DATA_US_2r after DLY;
            end if;
          end if;
        end if;
    end process;

END TX_CRC_ARCH;
